#+TITLE: Annotation
#+DRAWERS: HIDDEN
#+OPTIONS: d:RESULTS ^:nil
#+STARTUP: hideblocks align
#+PROPERTY:  header-args :exports results :eval never-export :mkdirp yes  :var DIR=(file-name-directory buffer-file-name) :colnames yes

#+BEGIN_COMMENT
The genomes table sets-up the annotation pipeline. Name is the output prefix,
Path is the path to the original fasta file relative to this README, Rename
indicates whether the fasta headers need to be renamed (0 or 1), and Filter is
the minimum contig length (0 for no filtering)
#+END_COMMENT
#+NAME: genomes
| Name  | Path                                   | Busco DB         | Rename | Filter |
|-------+----------------------------------------+------------------+--------+--------|
| D5.v1 | genomes/raimondii.juiced_V1.0.fasta.gz | embryophyta_odb9 |      0 |      0 |

#+BEGIN_COMMENT
The RNA table is used to specify RNA-seq libraries. Name should match an entry
in the genome table. Forward should be the path relative to this README for the
R1 file. If multiple libraries are available for a genome, then
separate the file names by a comma (no spaces). Reverse is the relative path for
the R2 file[s]. This column should be in the same order as the Forward column if
multiple libraries are given. Reverse column is left blank if the library is
single-end.
#+END_COMMENT
#+NAME: RNA
| Name  | Forward                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Reverse                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| D5.v1 | RNA-seq/D5/LD7-D5-L1_1.fq.gz,RNA-seq/D5/LD7-D5-L2_1.fq.gz,RNA-seq/D5/LD7-D5-L3_1.fq.gz,RNA-seq/D5/LD9-D5-L1_1.fq.gz,RNA-seq/D5/LD9-D5-L2_1.fq.gz,RNA-seq/D5/LD9-D5-L3_1.fq.gz,RNA-seq/D5/LDM-D5-L1_1.fq.gz,RNA-seq/D5/LDM-D5-L2_1.fq.gz,RNA-seq/D5/LDM-D5-L2-209_L1_1.fq.gz,RNA-seq/D5/LDM-D5-L3_1.fq.gz,RNA-seq/D5/SD5-D5-S1_1.fq.gz,RNA-seq/D5/SD5-D5-S3_1.fq.gz,RNA-seq/D5/SD7-D5-S1_1.fq.gz,RNA-seq/D5/SD7-D5-S2_1.fq.gz,RNA-seq/D5/SD7-D5-S3_1.fq.gz,RNA-seq/D5/SDM-D5-S1_1.fq.gz,RNA-seq/D5/SDM-D5-S2_1.fq.gz,RNA-seq/D5/SDP9-D5-S1_1.fq.gz,RNA-seq/D5/SDP9-D5-S2_1.fq.gz,RNA-seq/D5/SDP9-D5-S3_1.fq.gz,RNA-seq/D5/SDPF-D5-S1_1.fq.gz,RNA-seq/D5/SDPF-D5-S2_1.fq.gz,RNA-seq/D5/SDPF-D5-S3_1.fq.gz | RNA-seq/D5/LD7-D5-L1_2.fq.gz,RNA-seq/D5/LD7-D5-L2_2.fq.gz,RNA-seq/D5/LD7-D5-L3_2.fq.gz,RNA-seq/D5/LD9-D5-L1_2.fq.gz,RNA-seq/D5/LD9-D5-L2_2.fq.gz,RNA-seq/D5/LD9-D5-L3_2.fq.gz,RNA-seq/D5/LDM-D5-L1_2.fq.gz,RNA-seq/D5/LDM-D5-L2-209_L1_2.fq.gz,RNA-seq/D5/LDM-D5-L2_2.fq.gz,RNA-seq/D5/LDM-D5-L3_2.fq.gz,RNA-seq/D5/SD5-D5-S1_2.fq.gz,RNA-seq/D5/SD5-D5-S3_2.fq.gz,RNA-seq/D5/SD7-D5-S1_2.fq.gz,RNA-seq/D5/SD7-D5-S2_2.fq.gz,RNA-seq/D5/SD7-D5-S3_2.fq.gz,RNA-seq/D5/SDM-D5-S1_2.fq.gz,RNA-seq/D5/SDM-D5-S2_2.fq.gz,RNA-seq/D5/SDP9-D5-S1_2.fq.gz,RNA-seq/D5/SDP9-D5-S2_2.fq.gz,RNA-seq/D5/SDP9-D5-S3_2.fq.gz,RNA-seq/D5/SDPF-D5-S1_2.fq.gz,RNA-seq/D5/SDPF-D5-S2_2.fq.gz,RNA-seq/D5/SDPF-D5-S3_2.fq.gz |


#+BEGIN_SRC sh :tangle augustus/setup.sh
cd $DIR

cp -r /usr/local/igbb/augustus-3.2.3/config/             $DIR/augustus/
ln -s /usr/local/igbb/augustus-3.2.3/bin/                $DIR/augustus/
ln -s /usr/local/igbb/augustus-3.2.3/bin/                $DIR/augustus/src
ln -s /usr/local/igbb/augustus-3.2.3/include/            $DIR/augustus/
cp -r /usr/local/igbb/augustus-3.2.3/scripts/            $DIR/augustus/

cd $DIR/augustus/scripts
patch -s -p0 < $DIR/augustus/autoAug.patch #Untested


#+END_SRC
#+BEGIN_SRC sh :var genomes=genomes :tangle genomes/filter.sh
cd $DIR
ROOT=$(git rev-parse --show-toplevel)

PATH=$PATH:$DIR/augustus/scripts

for name in "${!genomes[@]}"; do
    readarray -t lib <<< "${genomes[$name]}"

    if [ ${lib[2]} -ne 0 ]; then
    pv "$DIR/${lib[0]}" | zcat |
      awk 'BEGIN {count=1}
            /^>/ {printf ">%s_%d\n", name, count++}
           !/^>/ {print}' name="${name}"  > "$DIR/genomes/$name.fa"
    else
        pv "$DIR/${lib[0]}" | zcat > "$DIR/genomes/$name.fa"
    fi

    mkdir $DIR/genomes/$name/

    if [ ${lib[3]} -ne 0 ]; then
        /home/maa146/bin/fasta_filter.pl "$DIR/${name}.fa" --length=${lib[3]} > "$DIR/genomes/${name}/filtered.fa"
    else
        ln -s "$DIR/genomes/$name.fa" "$DIR/genomes/$name/filtered.fa" 
    fi

    splitMfasta.pl --minsize=1000000 --outputpath="$DIR/genomes/$name/" "$DIR/genomes/$name/filtered.fa"

done

#+END_SRC

* RepeatMasker
#+HEADER: :prologue #PBS -N repeatmasker -l walltime=48:00:00
#+BEGIN_SRC sh :var libs=RNA[,0] :tangle RM/run.sh
cd $DIR
ROOT=$(git rev-parse --show-toplevel)

[ -z $name ] && exit
mkdir -p $DIR/RM/$name/$PBS_ARRAYID

ml igbb repeatmasker/4.0.7

RepeatMasker -pa $PBS_NUM_PPN -s -nolow -xsmall \
             -lib $DIR/RM/cottonRB23.04.fa \
             -no_is -frag 500000 -nocut -noisy -dir $DIR/RM/$name/$PBS_ARRAYID -html -gff \
             "$DIR/genomes/$name/filtered.split.$PBS_ARRAYID.fa"

cd $DIR/RM/$name/
tar -czf $PBS_ARRAYID.tar.gz $PBS_ARRAYID

#+END_SRC

#+BEGIN_SRC sh :tangle RM/combine.sh
cd $DIR
ROOT=$(git rev-parse --show-toplevel)
ml igbb repeatmasker/4.0.7

[ -z $name ] && exit

cat $DIR/RM/$name/*/filtered.split.*.fa.masked > $DIR/RM/$name.softmask.fa

zcat $DIR/RM/$name/*/filtered.split.*.fa.cat.gz | gzip > $DIR/RM/$name.cat.gz
ProcessRepeats -lib $DIR/RM/cottonRB23.04.fa $DIR/RM/$name.cat.gz

rmOutToGFF3.pl $DIR/RM/$name.out |
    grep -v -e "Satellite" -e ")n" -e "-rich" |
    perl -ane '$id; 
               if(!/^\#/){ 
                      @F = split(/\t/, $_); 
                      chomp $F[-1];
                      $id++; 
                      $F[-1] .= "\;ID=$id"; 
                      $_ = join("\t", @F)."\n"
               } 
               print $_' \
  > $DIR/RM/$name.gff
#+END_SRC

* BUSCO


#+HEADER: :shebang #!/bin/bash :tangle busco/run.sh :mkdirp yes
#+HEADER: :prologue #PBS -N busco -l nodes=1:ppn=12 -l walltime=192:00:00 -q q48p192h -t 1
#+BEGIN_SRC sh :var genomes=genomes[,0]
ml gcc/4.9.3
ml igbb augustus/3.2.3 blast/2.7.1 busco/3.1.0
export AUGUSTUS_CONFIG_PATH=$DIR/augustus/config

[ -z $name ] && exit

cd $DIR/busco
run_BUSCO.py -i $DIR/genomes/$name/filtered.fa \
             -l /work/datasets/igbb/busco/embryophyta_odb9 \
             -m genome \
             -c $PBS_NUM_PPN \
             -o $name \
             -r -t tmp_${lib[0]}

#RENAME augustus model parameters and link it to proper place
pushd run_$name/augustus_output/retraining_parameters
tmp_name=$(basename BUSCO_${name}_*_parameters.cfg _parameters.cfg)
ls -1 ${tmp_name}_* | sed "s/$tmp_name//" | xargs -i mv ${tmp_name}{} BUSCO_${name}{}
sed -i "s/$tmp_name/BUSCO_${name}/" BUSCO_${name}*

ln -s $DIR/busco/run_${name}/augustus_output/retraining_parameters \
   $DIR/augustus/config/species/BUSCO_${name}
popd

pushd run_$name
for dir in blast_output hmmer_output augustus_output single_copy_busco_sequences; do
  [ -d $dir ] && tar -czf $dir.tar.gz $dir
done
popd
#+END_SRC

* GeneMark

#+BEGIN_SRC sh :var genomes=genomes[,0]  :tangle genemark/run.sh
export PERL5LIB=$PERL5LIB:/usr/local/igbb/genemark-es-et_4.3.3/lib/perl5/
PATH=$PATH:$DIR/bin/gm_et_linux_64/gmes_petap/

cd $DIR
ROOT=$(git rev-parse --show-toplevel)

[ -z $name ] && exit

mkdir $DIR/genemark/$name 
cd $DIR/genemark/$name

gmes_petap.pl --ES --cores $PBS_NUM_PPN --sequence $DIR/genomes/$name/filtered.fa 
#+END_SRC

* SNAP

#+BEGIN_SRC sh :var genomes=genomes[,0] :tangle snap/train.sh
cd $DIR/snap
ROOT=$(git rev-parse --show-toplevel)

ml igbb
ml snap/2013-11-29 bioperl/1.6

[ -z $name ] && exit


mkdir -p $DIR/snap/tmp_$name/params
pushd $DIR/snap/tmp_$name

cat $DIR/busco/run_$name/augustus_output/gffs/* |
    perl /usr/local/igbb/busco_v2/scripts/gff3_to_zff.pl  > $name.ann

grep '^>' $name.ann | tr -d '>' > $name.seqs2keep
perl /usr/local/igbb/busco_v2/scripts/fasta_sort.pl $name.seqs2keep <  $DIR/genomes/$name/filtered.fa  > $name.dna
fathom $name.ann $name.dna -gene-stats > gene-stats.log 2>&1
fathom $name.ann $name.dna -validate > validate.log 2>&1
fathom $name.ann $name.dna -categorize 1000 > categorize.log 2>&1
fathom uni.ann uni.dna -export 1000 -plus > uni-plus.log 2>&1

pushd params
forge ../export.ann ../export.dna > ../forge.log 2>&1
popd

hmm-assembler.pl $name params/ > $DIR/snap/$name.hmm

popd
#+END_SRC

* MAKER.1
#+BEGIN_SRC sh :var genomes=genomes[,0] :tangle maker.1/setup.sh
cd $DIR/
ROOT=$(git rev-parse --show-toplevel)

[ -z $name ] && exit

ml igbb
ml maker/2.31.9

AUGUSTUS_CONFIG_PATH=$DIR/augustus/config


declare -A maker_opts
maker_opts["genome"]=$DIR/genomes/$name/filtered.fa
maker_opts["protein"]=/work/datasets/igbb/uniprot_sprot.20181010.fasta  #protein sequence fasta file (i.e. from mutiple oransisms)
maker_opts["protein"]+=",$DIR/ref/G.raimondii_JGI_221_v2.1.proteins.fasta"

maker_opts["model_org"]=""
maker_opts["repeat_protein"]=/usr/local/igbb/maker-2.31.9/data/te_proteins.fasta #transposable element proteins for RepeatRunner
maker_opts["rm_gff"]=$DIR/RM/D5.v1.gff #pre-identified repeat elements from an external GFF3 file
maker_opts["snaphmm"]=$DIR/snap/${name}.hmm #SNAP HMM file
maker_opts["gmhmm"]=$DIR/genemark/${name}/output/gmhmm.mod #GeneMark HMM file
maker_opts["augustus_species"]=BUSCO_$name #Augustus gene prediction species model
maker_opts["pred_gff"]= #ab-initio predictions from an external GFF3 file

maker_opts["alt_splice"]=0 #Take extra steps to try and find alternative splicing, 1 = yes, 0 = no
maker_opts["always_complete"]=0 #extra steps to force start and stop codons, 1 = yes, 0 = no

maker_opts["clean_try"]=1 #remove all data from previous run before retrying, 1 = yes, 0 = no
maker_opts["clean_up"]=1 #removes theVoid directory with individual analysis files, 1 = yes, 0 = no


declare -A maker_exe
maker_exe["probuild"]=$DIR/bin/gm_et_linux_64/gmes_petap/probuild
maker_exe["gmhmme3"]=$DIR/bin/gm_et_linux_64/gmes_petap/gmhmme3

#HACK: Add augustus path to end of augustus_species because maker's augustus run
#      does not respect the AUGUSTUS_CONFIG_PATH env variable
maker_opts["augustus_species"]+=" --AUGUSTUS_CONFIG_PATH=$AUGUSTUS_CONFIG_PATH"

mkdir $DIR/maker.1/${name}
cd $DIR/maker.1/${name}

maker -CTL

for key in "${!maker_opts[@]}"; do
    value=${maker_opts[$key]}
    sed --follow-symlinks -i "s#^\($key *=\).*#\1$value#" maker_opts.ctl
done

for key in "${!maker_exe[@]}"; do
    value=${maker_exe[$key]}
    sed --follow-symlinks -i "s#^\($key *=\).*#\1$value#" maker_exe.ctl
done


#+END_SRC

#+HEADER: :prologue #PBS -N maker -l walltime=48:00:00
#+BEGIN_SRC sh :var genomes=genomes[,0] :tangle maker.1/run.sh
cd $DIR/
ROOT=$(git rev-parse --show-toplevel)

[ -z $name ] && exit

ml igbb
ml maker/2.31.9

cd $DIR/maker.1/$name || exit
mkdir -p $DIR/maker.1/$name/tmp/$PBS_ARRAYID

maker -fix_nucleotides \
      -b $PBS_ARRAYID \
      -g "$DIR/genomes/$name/filtered.split.$PBS_ARRAYID.fa" \
      -c $PBS_NUM_PPN \
      -TMP $DIR/maker.1/$name/tmp/$PBS_ARRAYID/ \
      --ignore_nfs_tmp \
    |& tee ${PBS_ARRAYID}.log

rm -R $DIR/maker/$name/tmp/$PBS_ARRAYID
tar -czf $PBS_ARRAYID.tar.gz $PBS_ARRAYID.maker.output/${PBS_ARRAYID}_{datastore/,master_datastore_index.log} $PBS_ARRAYID.log
#+END_SRC

#+BEGIN_SRC sh :var genomes=genomes[,0] :tangle maker.1/merge.sh
cd $DIR/
ROOT=$(git rev-parse --show-toplevel)

[ -z $name ] && exit

ml igbb
ml maker/2.31.9

cd $DIR/maker.1/$name || exit

find $DIR/maker.1/$name -name "*_master_datastore_index.log" -printf "%P\n" |
    xargs awk 'function dirname (pathname){
    	                if (!sub(/\/[^\/]*\/?$/, "", pathname))
                           return "."
                        else if (pathname != "")
                           return pathname
                        else
                           return "/"
               }
               {file=dirname(FILENAME); 
                $2 = file "/" $2;} 1;' OFS="\t" > $DIR/maker.1/$name/master_datastore_index.log
    
maker2zff -e0 -c0 -d master_datastore_index.log
  
gff3_merge -s -n -d master_datastore_index.log > $DIR/maker.1/$name.gff3
#+END_SRC

* AutoAug
#+HEADER: :prologue #PBS -N AutoAug -l walltime=48:00:00
#+BEGIN_SRC sh :var genomes=genomes[,0] :tangle augustus/train.sh
cd $DIR/
ROOT=$(git rev-parse --show-toplevel)

[ -z $name ] && exit

ml igbb
ml maker/2.31.9

export AUGUSTUS_CONFIG_PATH=$DIR/augustus/config

mkdir $DIR/augustus/$name/

$DIR/augustus/scripts/autoAug.pl \
    --genome=$DIR/genomes/$name/filtered.fa \
    --species=$name \
    --threads=$PBS_NUM_PPN \
    --trainingset=$DIR/maker.1/$name/$name.gff3 \
    --workingdir=$DIR/augustus/$name/ \
    --singleCPU -v --useexisting

cd $DIR/augustus/
tar -czf $name.config.tar.gz config/species/$name
tar -czf $name.autoaug.tar.gz $name/

#+END_SRC

* MAKER.2
#+BEGIN_SRC sh :var genomes=genomes[,0] :tangle maker.2/setup.sh
cd $DIR/
ROOT=$(git rev-parse --show-toplevel)

[ -z $name ] && exit

ml igbb
ml maker/2.31.9

AUGUSTUS_CONFIG_PATH=$DIR/augustus/config

mkdir $DIR/maker.2/${name}

# Reuse est, protien, and repeat alignments from maker first pass 
awk '$2 == "est2genome"' $DIR/maker.1/$name.gff3 > $DIR/maker.2/$name/est2genome.gff
awk '$2 == "protein2genome"' $DIR/maker.1/$name.gff3 > $DIR/maker.2/$name/protein2genome.gff
awk '$2 ~ "repeat"' $DIR/maker.1/$name.gff3 > $DIR/maker.2/$name/repeats.gff

declare -A maker_opts
maker_opts["genome"]=$DIR/genomes/$name/filtered.fa
maker_opts["est_gff"]=$DIR/maker.2/$name/est2genome.gff         #aligned ESTs or mRNA-seq from an external GFF3 file
maker_opts["protein_gff"]=$DIR/maker.2/$name/protein2genome.gff #aligned protein homology evidence from an external GFF3 file

maker_opts["model_org"]=""
maker_opts["repeat_protein"]=""
maker_opts["rm_gff"]=$DIR/maker.2/$name/repeats.gff             #pre-identified repeat elements from an external GFF3 file
maker_opts["snaphmm"]=$DIR/snap/${name}.hmm                     #SNAP HMM file
maker_opts["gmhmm"]=$DIR/genemark/${name}/output/gmhmm.mod      #GeneMark HMM file
maker_opts["augustus_species"]=$name                            #Augustus gene prediction species model
maker_opts["pred_gff"]=$DIR/mikado/$name/mikado.loci.gff3       #ab-initio predictions from an external GFF3 file

maker_opts["alt_splice"]=1                                      #find alternative splicing
maker_opts["always_complete"]=1                                 #force start and stop codons

maker_opts["clean_try"]=1                                       #remove all data from previous run before retrying
maker_opts["clean_up"]=1                                        #removes theVoid directory 


declare -A maker_exe
maker_exe["probuild"]=$DIR/bin/gm_et_linux_64/gmes_petap/probuild
maker_exe["gmhmme3"]=$DIR/bin/gm_et_linux_64/gmes_petap/gmhmme3

#HACK: Add augustus path to end of augustus_species because maker's augustus run
#      does not respect the AUGUSTUS_CONFIG_PATH env variable
maker_opts["augustus_species"]+=" --AUGUSTUS_CONFIG_PATH=$AUGUSTUS_CONFIG_PATH"

cd $DIR/maker.2/${name}
maker -CTL

for key in "${!maker_opts[@]}"; do
    value=${maker_opts[$key]}
    sed --follow-symlinks -i "s#^\($key *=\).*#\1$value#" maker_opts.ctl
done

for key in "${!maker_exe[@]}"; do
    value=${maker_exe[$key]}
    sed --follow-symlinks -i "s#^\($key *=\).*#\1$value#" maker_exe.ctl
done


#+END_SRC

#+HEADER: :prologue #PBS -N maker -l walltime=48:00:00
#+BEGIN_SRC sh :var genomes=genomes[,0] :tangle maker.2/run.sh
cd $DIR/
ROOT=$(git rev-parse --show-toplevel)

[ -z $name ] && exit

ml igbb
ml maker/2.31.9

cd $DIR/maker.2/$name || exit
mkdir -p $DIR/maker.2/$name/tmp/$PBS_ARRAYID

maker -fix_nucleotides \
      -b $PBS_ARRAYID \
      -g "$DIR/genomes/$name/filtered.split.$PBS_ARRAYID.fa" \
      -c $PBS_NUM_PPN \
      -TMP $DIR/maker.2/$name/tmp/$PBS_ARRAYID/ \
      --ignore_nfs_tmp \
    |& tee ${PBS_ARRAYID}.log

rm -R $DIR/maker.2/$name/tmp/$PBS_ARRAYID
tar -C $DIR/maker.2/$name/ \
    -czf $PBS_ARRAYID.tar.gz \
    $PBS_ARRAYID.maker.output/${PBS_ARRAYID}_{datastore/,master_datastore_index.log} $PBS_ARRAYID.log
#+END_SRC

#+BEGIN_SRC sh :var genomes=genomes[,0] :tangle maker.2/merge.sh
cd $DIR/
ROOT=$(git rev-parse --show-toplevel)

[ -z $name ] && exit

ml igbb
ml maker/2.31.9

cd $DIR/maker.2/$name || exit

find $DIR/maker.2/$name -name "*_master_datastore_index.log" -printf "%P\n" |
    xargs awk 'function dirname (pathname){
    	                if (!sub(/\/[^\/]*\/?$/, "", pathname))
                           return "."
                        else if (pathname != "")
                           return pathname
                        else
                           return "/"
               }
               {file=dirname(FILENAME); 
                $2 = file "/" $2;} 1;' OFS="\t" > $DIR/maker.2/$name/master_datastore_index.log
    
maker2zff -e0 -c0 -d master_datastore_index.log
  
gff3_merge -s -n -g -d master_datastore_index.log > $DIR/maker.2/$name.gff3
#+END_SRC

* Functional

** IPRScan

#+HEADER: :prologue #PBS -N iprscan -l walltime=12:00:00
#+BEGIN_SRC sh :var genomes=genomes[,0] :tangle iprscan/run.sh
cd $DIR/
ROOT=$(git rev-parse --show-toplevel)

[ -z $name ] && exit

ml igbb maker/2.31.9 blast/2.7.1 python/3.6.2
PATH=/usr/local/java/jdk1.8.0_92/bin/:$PATH


mkdir -p $DIR/iprscan/$name/$PBS_ARRAYID
cd $DIR/iprscan/$name/$PBS_ARRAYID

fasta_merge -d $DIR/maker.2/$name/$PBS_ARRAYID.maker.output/${PBS_ARRAYID}_master_datastore_index.log -o $PBS_ARRAYID

$DIR/bin/interproscan-5.32-71.0/interproscan.sh \
   -i $DIR/iprscan/$name/$PBS_ARRAYID/$PBS_ARRAYID.all.maker.proteins.fasta \
   -f xml,tsv \
   -pathways \
   -iprlookup \
   -goterms \
   -dp  \
   -appl 'Pfam, PRINTS, PANTHER, TIGRFAM, SUPERFAMILY, PIRSF, ProSiteProfiles, ProSitePatterns, SMART' \
   -b iprscan.$PBS_ARRAYID \
   -cpu $PBS_NUM_PPN

#+END_SRC


** BLAST
#+HEADER: :prologue #PBS -N blast -l walltime=12:00:00
#+BEGIN_SRC sh :var genomes=genomes[,0] :tangle blast/run.sh
cd $DIR/
ROOT=$(git rev-parse --show-toplevel)

[ -z $name ] && exit

ml igbb maker/2.31.9 blast/2.7.1 python/3.6.2
PATH=/usr/local/java/jdk1.8.0_92/bin/:$PATH


mkdir -p $DIR/blast/$name/
cd $DIR/blast/$name/

fasta_merge -d $DIR/maker.2/$name/$PBS_ARRAYID.maker.output/${PBS_ARRAYID}_master_datastore_index.log -o $PBS_ARRAYID

blastp -query $DIR/blast/$name/$PBS_ARRAYID.all.maker.proteins.fasta \
       -db /work/datasets/igbb/uniprot_sprot.20181010.fasta \
       -outfmt 6 \
       -out $DIR/blast/$name/$PBS_ARRAYID.out \
       -num_threads $PBS_NUM_PPN



#+END_SRC

* Finalize

** Rename
#+BEGIN_SRC sh :var genomes=genomes[,0] :tangle final/run.sh
cd $DIR/
ROOT=$(git rev-parse --show-toplevel)

[ -z $name ] && exit

ml igbb maker/2.31.9

prefix=$DIR/final/$name

maker_map_ids --prefix ${name}_ --justify 8 $DIR/maker.2/$name.gff3 > $prefix.map
cp $DIR/maker.2/$name.gff3 $DIR/final/
map_gff_ids $prefix.{map,gff3}

#Since mikado adds a name to the gff and maker's fasta_merge uses the name if
#one exists, we need to add all the mikado names to the map file
perl -wlane 'chomp; next unless $F[8];
             my $d = {map {split /=/, $_, 2} split /;/, $F[8]}; 
             if($d->{Name} && $d->{Name} ne $d->{ID}){
                printf "%s\t%s\n", @$d{qw/Name ID/}
             } '   final/D5.v1.pred.gff3 >> $prefix.map


fasta_merge -d $DIR/maker.2/$name/master_datastore_index.log -o $prefix
cat $DIR/iprscan/$name/*/iprscan.*.tsv > $prefix.iprscan
cat $DIR/blast/$name/*.out             > $prefix.blastp

map_fasta_ids $prefix.map   $prefix.all.maker.proteins.fasta
map_fasta_ids $prefix.map   $prefix.all.maker.transcripts.fasta
map_data_ids  $prefix.map   $prefix.iprscan
map_data_ids  $prefix.map   $prefix.blastp

uniprot=/work/datasets/igbb/uniprot_sprot.20181010.fasta
maker_functional_gff   $uniprot $prefix.blastp $prefix.gff3                        > $prefix.putative_function.gff3
maker_functional_fasta $uniprot $prefix.blastp $prefix.all.maker.proteins.fasta    > $prefix.proteins.putative_function.fa
maker_functional_fasta $uniprot $prefix.blastp $prefix.all.maker.transcripts.fasta > $prefix.transcripts.putative_function.fa

ipr_update_gff $prefix.putative_function.gff3 $prefix.iprscan > $prefix.putative_function.domain_added.gff3

mv $prefix.putative_function.domain_added.gff3 $prefix.gff3
mv $prefix.proteins.putative_function.fa       $prefix.proteins.fa
mv $prefix.transcripts.putative_function.fa    $prefix.transcripts.fa

rm $prefix.all.maker.*.fasta $prefix.map $prefix.putative_function.gff3 $prefix.iprscan $prefix.blastp
cp $DIR/genomes/$name.fa $prefix.fa
#+END_SRC

** Busco
#+HEADER: :prologue #PBS -N busco -l walltime=192:00:00
#+BEGIN_SRC sh :var genomes=genomes :tangle final/busco.sh
cd $DIR/
ROOT=$(git rev-parse --show-toplevel)

ml python/2.7.8
ml igbb busco/3.1.0

[ -z $name ] && exit

readarray -t lib <<< "${genomes[$name]}"

cd $DIR/final/

echo run_BUSCO.py -i $DIR/final/$name.transcripts.fa \
             -l /work/datasets/igbb/busco/${lib[1]} \
             -m transcriptome \
             -c $PBS_NUM_PPN \
             -o $name \
             -t tmp_${name}

pushd run_$name
for dir in blast_output hmmer_output augustus_output single_copy_busco_sequences; do
  [ -d $dir ] && tar -czf $dir.tar.gz $dir
done
popd


#+END_SRC

** Graphs


#+BEGIN_SRC R :tangle final/graph.R
library(ggplot2)
library(reshape2)

args = commandArgs(trailingOnly=TRUE)
name = args[1]

getAttributeField <- function (x, field, attrsep = ";") {
    s = strsplit(x, split = attrsep, fixed = TRUE)
    sapply(s, function(atts) {
        a = strsplit(atts, split = "=", fixed = TRUE)
        m = match(field, sapply(a, "[", 1))
        if (!is.na(m)) {
            rv = a[[m]][2]
        } else {
            rv = as.character(NA)
        }
        return(rv)
    })
}

gffRead <- function(gffFile, nrows = -1) {
    cat("Reading ", gffFile, ": ", sep="")
    gff = read.table(gffFile, sep="\t", as.is=TRUE, quote="", header=FALSE, comment.char="#", nrows = nrows,
                     colClasses=c("character", "character", "character", "integer", "integer", "character",
                                  "character", "character", "character"))
    colnames(gff) = c("seqname", "source", "feature", "start", "end", "score", "strand", "frame", "attributes")
    cat("found", nrow(gff), "rows with classes:", paste(sapply(gff, class), collapse=", "), "\n")
    return(gff)
} 

gff <- gffRead(file.path(DIR,'final', paste0(name, '.gff3')))

mrna <- subset(gff, feature == 'mRNA')

data=as.data.frame(do.call(rbind, lapply(strsplit(getAttributeField(mrna$attributes, '_QI'), split="\\|"), as.numeric)))
colnames(data) = c("5′UTR Length",
                 "splice sites confirmed by an EST/mRNA-seq alignment",
                 "exons that match an EST/mRNA-seq alignment",
                 "exons that overlap EST/mRNA-seq or protein alignments",
                 "splice sites confirmed by ab-initio gene prediction",
                 "exons that overlap an ab-initio gene prediction",
                 "Number of exons",
                 "3′UTR Length",
                 "Protein Length")
data$AED  <- as.numeric(getAttributeField(mrna$attributes, '_AED'));
data$eAED <- as.numeric(getAttributeField(mrna$attributes, '_eAED'));

p <- ggplot(data, aes(x=AED)) + geom_histogram(bins=100) + theme_bw()
ggsave(file.path(DIR,'final', paste0(name, ".AED.histo.png")), p, width=7, height=3.5)
p <- ggplot(data, aes(x=AED)) + stat_ecdf() + theme_bw()
ggsave(file.path(DIR,'final', paste0(name, ".AED.cdf.png")), p, width=7, height=3.5)

p <- ggplot(data, aes(x=eAED)) + geom_histogram(bins=100) + theme_bw()
ggsave(file.path(DIR,'final', paste0(name, ".eAED.histo.png")), p, width=7, height=3.5)
p <- ggplot(data, aes(x=eAED)) + stat_ecdf() + theme_bw()
ggsave(file.path(DIR,'final', paste0(name, ".eAED.cdf.png")), p, width=7, height=3.5)



data.melt = melt(data)
data.melt$scale = data.melt$variable

levels(data.melt$scale) <- list(
                   "Length" = c("5′UTR Length", "3′UTR Length", "Protein Length"),
                   "Homology" = c("splice sites confirmed by an EST/mRNA-seq alignment",
                                  "exons that match an EST/mRNA-seq alignment",
                                  "exons that overlap EST/mRNA-seq or protein alignments"),
                   "Ab-Initio" = c("splice sites confirmed by ab-initio gene prediction",
                                   "exons that overlap an ab-initio gene prediction"),
                   "Count"="Number of exons",
                   "Probability" = c("AED", "eAED")
)
p <- ggplot(data.melt, aes(x=variable, y=value)) + geom_boxplot() + facet_wrap(~scale, scales='free', ncol=1) + coord_flip()
ggsave(file.path(DIR,'final', paste0(name, ".QI.png")), p, width=7, height=9)


data <- subset(data, AED <= 0.5)

data.melt = melt(data)
data.melt$scale = data.melt$variable

levels(data.melt$scale) <- list(
                   "Length" = c("5′UTR Length", "3′UTR Length", "Protein Length"),
                   "Homology" = c("splice sites confirmed by an EST/mRNA-seq alignment",
                                  "exons that match an EST/mRNA-seq alignment",
                                  "exons that overlap EST/mRNA-seq or protein alignments"),
                   "Ab-Initio" = c("splice sites confirmed by ab-initio gene prediction",
                                   "exons that overlap an ab-initio gene prediction"),
                   "Count"="Number of exons",
                   "Probability" = c("AED", "eAED")
)
p <- ggplot(data.melt, aes(x=variable, y=value)) + geom_boxplot() + facet_wrap(~scale, scales='free', ncol=1) + coord_flip()
ggsave(file.path(DIR,'final', paste0(name,".QI.filter.png")), p, width=7, height=9)


data=data.frame(ID=getAttributeField(mrna$attributes, 'ID'), AED=as.numeric(getAttributeField(mrna$attributes, '_AED')))

aed.counts <- as.data.frame(table(data$AED))
aed.counts$cumsum <- cumsum(aed.counts$Freq)
aed.counts$group <- "Gene Counts";
aed.counts$variable <- "Complete";
aed.counts$Freq <- NULL
colnames(aed.counts) <- c("AED", "value", "group", "variable")
aed.counts$AED <- as.numeric(as.character(aed.counts$AED))

busco=read.delim(file.path(DIR, 'final', paste0('run_', name), paste0('full_table_', name, '.tsv')), 
                 comment.char='#', col.names=c('Busco', 'Type', 'ID', 'Score', 'Length'), header=F, stringsAsFactors=F)
busco$Type = factor(busco$Type)
data=merge(busco, data)
all_busco = unique

classify <- function (data, aed){
    subset <- data[data$AED <= aed,];
    subset[subset$Type == "Duplicated","Type"] <- "Complete";

    r <- as.list(summary(subset$Type));
    cd <- (table(subset[subset$Type == "Complete", "Busco"])>1)
    r$Duplicated <- sum(cd);
    r$Complete <- sum(cd == FALSE);
    r$Missing <- 1440 - r$Duplicated - r$Complete - r$Fragmented
    r$AED <- aed
    return(unlist(r));
}




test <- melt(as.data.frame(t(sapply(seq(0,1,0.01), classify, data=data))), id.vars='AED')
test$group <- "BUSCO"

test$variable <- factor(test$variable, levels=rev(levels(test$variable)))

d <- rbind(test, aed.counts)
d$AED <- as.numeric(d$AED)

p <- ggplot(test, aes(x=AED, group=variable, fill=variable)) +
#    geom_rect(fill="#fdbf6f", xmin=-0.1, xmax=1.1, ymin=0, ymax=4584)+
    geom_bar(aes(weight=value),width=0.01) +
#    scale_fill_manual(values = c('#33a02c', '#b2df8a', '#a6cee3', "#fdbf6f" )) +
    geom_line(data=aed.counts, aes(y=value)) +
    scale_x_continuous(breaks=seq(0, 1, by=0.1), sec.axis = dup_axis()  ) +
    facet_grid(group~.,scales='free_y')
ggsave(file.path(DIR,'final', paste0(name, ".busco_vs_aed.png")), p, width=7, height=3.5)
#+END_SRC

